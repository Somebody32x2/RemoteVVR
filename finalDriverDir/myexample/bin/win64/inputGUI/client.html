<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
          name="viewport">
    <meta content="ie=edge" http-equiv="X-UA-Compatible">
    <title>Virtual Controller</title>
    <script crossorigin="anonymous"
            integrity="sha512-3WFaXQUsbGieECwv3t3DvyAkZ7pp+/rIKOQnx7NKhfwIF0u2l+DYsE2eF635ewJVj3YTU4/Ug6UqEkSTZCiSew=="
            referrerpolicy="no-referrer" src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.4.1/socket.io.min.js"></script>

    <link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css"
          integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" rel="stylesheet">
    <script crossorigin="anonymous"
            integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
            src="https://code.jquery.com/jquery-3.2.1.slim.min.js"></script>
    <script crossorigin="anonymous"
            integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"
            src="https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js"></script>
    <script crossorigin="anonymous"
            integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
            src="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js"></script>

    <script crossorigin="anonymous"
            integrity="sha512-keI4Ym3b3tf6N3hp1a1Z8OwXaiZwIu+aNYbU1Rx3QnDAeu8sLGT8ZcBJy5yVbPp9GXyMtr2RGBftngo3K5b4aw=="
            referrerpolicy="no-referrer" src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.0/cannon.js"></script>


    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">

</head>
<body>
<div id="buttons">
    <!--    ABXY Buttons-->
    <div class="" id="Y">
        <input autocomplete="off" class="btn-check" id="Y-btn" type="checkbox">
        <label class="btn btn-outline-primary" for="Y-btn"
               onclick="setButton('Y', document.getElementById('Y-btn').checked)">Y</label>

    </div>
    <div class="" id="X">
        <input autocomplete="off" class="btn-check" id="X-btn" type="checkbox">
        <label class="btn btn-outline-primary" for="X-btn"
               onclick="setButton('X', document.getElementById('X-btn').checked)">X</label>

    </div>
    <div class="" id="B">
        <input autocomplete="off" class="btn-check" id="B-btn" type="checkbox">
        <label class="btn btn-outline-primary" for="B-btn"
               onclick="setButton('B', document.getElementById('B-btn').checked)">B</label>

    </div>
    <div class="" id="A">
        <input autocomplete="off" class="btn-check" id="A-btn" type="checkbox">
        <label class="btn btn-outline-primary" for="A-btn"
               onclick="setButton('A', document.getElementById('A-btn').checked)">A</label>

    </div>
    <div class="" id="SYS">
        <input autocomplete="off" class="btn-check" id="SYS-btn" type="checkbox">
        <label class="btn btn-outline-primary" for="SYS-btn"
               onclick="setButton('system', document.getElementById('SYS-btn').checked)">SYS</label>

    </div>

    <!--    <input autocomplete="off" class="btn-check" id="shuffle-btn" type="checkbox">-->
    <!--    <label class="btn btn-outline-success" for="shuffle-btn">Shuffle</label>-->
</div>
<div id="settings">
    <label for="posScaleInput">Position Scale:</label><input id="posScaleInput" onchange="positionScale = this.value * -0.005" type="number"
                                                             value="1">
    <label for="rotScaleInput">Rotation Scale:</label><input id="rotScaleInput" onchange="rotationScale = this.value" type="number"
                                                             value="1">
    <label for="setWhat">Set </label><select id="setWhat" onchange="updateSetWhat(this.value)">
    <option value="null" selected></option>
        <optgroup label="Position">
            <option value="positionX">Position X</option>
            <option value="positionY">Position Y</option>
            <option value="positionZ">Position Z</option>
        </optgroup>
        <optgroup label="Rotation">
            <option value="rotationX">Rotation X</option>
            <option value="rotationY">Rotation Y</option>
            <option value="rotationZ">Rotation Z</option>
        </optgroup>
        <optgroup label="Joystick">
            <option value="joystickX">Joystick X</option>
            <option value="joystickY">Joystick Y</option>
        </optgroup>
        <optgroup label="Trackpad">
            <option value="trackpadX">Trackpad X</option>
            <option value="trackpadY">Trackpad Y</option>
        </optgroup>
        <optgroup label="Trigger">
            <option value="triggerV">Trigger Value</option>
            <option value="triggerC">Trigger Pressed</option>
        </optgroup>
    </select>
    <label for="setTo">To </label><input id="setTo" type="number" data-set-variable="" onchange="
        if (this.getAttribute('data-set-variable') !== 'trigger[1]') eval(this.getAttribute('data-set-variable') +'='+this.value)
        else eval(this.getAttribute('data-set-variable') +'='+this.checked)
">
</div>
</body>
<style>
    body {
        margin: 0;
        height: 100vh;
    }

    #defaultCanvas0 {
        /*Backgroud Canvas Css*/
        width: 100%;
        height: 99.9%;
        position: fixed;
        top: 0;
        left: 0;
        z-index: -1;

    }

    #buttons {
        position: absolute;
        width: 15%;
        height: 15%;
        /*    Right Center Align*/
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        display: grid;
        gap: 4px;
        /*    Place the objects like this:
              y  b
            x     a*/

        grid-template-areas:
        ". a ."
        "b s c"
        ". d .";
    }

    #buttons > div > label {
        width: 100%;
        height: 100%;
        font-size: 1.3rem;
    }

    #Y {
        grid-area: a;
    }

    #X {
        grid-area: b;
    }

    #B {
        grid-area: c;
    }

    #A {
        grid-area: d;
    }
    #SYS {
        grid-area: s;
    }

    #settings {
        /*    Move to bottom Right*/
        position: absolute;
        bottom: 10px;
        right: 10px;
        display: grid;
        gap: 4px;
        grid-template-columns: 1fr 1fr;
    }
</style>
<script>
    // let socket = io.connect('http://localhost:3000');
    let socket = io.connect('https://samuelshuster.com/webcontroller');
    socket.on('connect', function () {
        console.log('Connected');
    });
    socket.on('disconnect', function () {
        console.log('Disconnected');
    });
    socket.on('message', function (data) {
        console.log(data);
    });

    // Emit all initial values
    socket.emit('button', "A", false);
    socket.emit('button', "B", false);
    socket.emit('button', "X", false);
    socket.emit('button', "Y", false);
    socket.emit('button', "system", false);
    socket.emit('joystick', 0, 0);
    socket.emit('touchpad', 0, 0);
    socket.emit('trigger', 0, false);
    socket.emit('position', 0, 0, 0);
    socket.emit('rotation', 0, 0, 0, 1);


    function setButton(button, state) {
        console.log(button, !state);
        socket.emit('button', button.toLowerCase(), !state);
    }

    function setup() {
        createCanvas(windowWidth, windowHeight, WEBGL);
        background(255);
        textFont(loadFont('https://fonts.cdnfonts.com/s/29856/MajorMonoDisplay-Regular.woff'));
        // debugMode();
    }

    let lastTouchpad = [0, 0];
    let lastJoystick = [0, 0]
    let lastPosition = [0, 0, 0];
    let positionScale = -0.005; // Negative to invert - See settings input to change base/initial value
    let rotationScale = 1;
    let trigger = [0, false]
    let oldTrigger = [0, false]
    let lastTrig = 0;
    let eulerRotation = [0, 0, 0];
    let overrideTrigger = false;
    
    function updateSetWhat(what) {
        switch (what) {
            case "positionX":
                document.getElementById("setTo").setAttribute("type", "number");
                document.getElementById("setTo").value = lastPosition[0];
                document.getElementById("setTo").setAttribute("data-set-variable", "lastPosition[0]");
                break;
            case "positionY":
                document.getElementById("setTo").setAttribute("type", "number");
                document.getElementById("setTo").value = lastPosition[1];
                document.getElementById("setTo").setAttribute("data-set-variable", "lastPosition[1]");
                break;
            case "positionZ":
                document.getElementById("setTo").setAttribute("type", "number");
                document.getElementById("setTo").value = lastPosition[2];
                document.getElementById("setTo").setAttribute("data-set-variable", "lastPosition[2]");
                break;
            case "rotationX":
                document.getElementById("setTo").setAttribute("type", "number");
                document.getElementById("setTo").value = eulerRotation[0];
                document.getElementById("setTo").setAttribute("data-set-variable", "eulerRotation[0]");
                break;
            case "rotationY":
                document.getElementById("setTo").setAttribute("type", "number");
                document.getElementById("setTo").value = eulerRotation[1];
                document.getElementById("setTo").setAttribute("data-set-variable", "eulerRotation[1]");
                break;
            case "rotationZ":
                document.getElementById("setTo").setAttribute("type", "number");
                document.getElementById("setTo").value = eulerRotation[2];
                document.getElementById("setTo").setAttribute("data-set-variable", "eulerRotation[2]");
                break;
            case "joystickX":
                document.getElementById("setTo").setAttribute("type", "number");
                document.getElementById("setTo").value = lastJoystick[0];
                document.getElementById("setTo").setAttribute("data-set-variable", "lastJoystick[0]");
                break;
            case "joystickY":
                document.getElementById("setTo").setAttribute("type", "number");
                document.getElementById("setTo").value = lastJoystick[1];
                document.getElementById("setTo").setAttribute("data-set-variable", "lastJoystick[1]");
                break;
            case "trackpadX":
                document.getElementById("setTo").setAttribute("type", "number");
                document.getElementById("setTo").value = lastTouchpad[0];
                document.getElementById("setTo").setAttribute("data-set-variable", "lastTouchpad[0]");
                break;
            case "trackpadY":
                document.getElementById("setTo").setAttribute("type", "number");
                document.getElementById("setTo").value = lastTouchpad[1];
                document.getElementById("setTo").setAttribute("data-set-variable", "lastTouchpad[1]");
                break;
            case "triggerV":
                document.getElementById("setTo").value = trigger[0];
                document.getElementById("setTo").setAttribute("type", "number");
                document.getElementById("setTo").setAttribute("data-set-variable", "trigger[0]");
                overrideTrigger = true;
                break;
            case "triggerC":
                document.getElementById("setTo").setAttribute("data-set-variable", "trigger[1]");
                document.getElementById("setTo").setAttribute("type", "checkbox");
                document.getElementById("setTo").checked = trigger[1];
                overrideTrigger = true;
                break;


        }
    }

    function draw() {
        // orbitControl();
        push();
        push();
        translate(-width / 2, -height / 2, 0);
        background(255);

        textSize(20);
        fill(0);
        text('Touchpad', 40, 40);

        noFill()
        square(10, 60, 300);
        circle(160, 210, 300);

        fill(0)
        circle(lastTouchpad[0] + 160, lastTouchpad[1] + 210, 20);
        // If the touchpad is pressed update and send lastTouchpad
        if (mouseIsPressed && mouseX > 10 && mouseX < 310 && mouseY > 60 && mouseY < 360) {
            lastTouchpad = [mouseX - 160, mouseY - 210];
            relativeTouchpad = [lastTouchpad[0] / 150, lastTouchpad[1] / 150];
            socket.emit('touchpad', relativeTouchpad[0].toFixed(3), -relativeTouchpad[1].toFixed(3));
        }

        text('Joystick', 40, 400);
        noFill()
        square(10, 430, 300);
        circle(160, 580, 300);
        fill(0)
        circle(lastJoystick[0] + 160, lastJoystick[1] + 580, 20);
        // If the joystick is pressed update and send lastJoystick
        if (mouseIsPressed && mouseX > 10 && mouseX < 310 && mouseY > 430 && mouseY < 730) {
            lastJoystick = [mouseX - 160, mouseY - 580];
            relativeJoystick = [lastJoystick[0] / 150, lastJoystick[1] / 150];
            socket.emit('joystick', relativeJoystick[0].toFixed(3), -relativeJoystick[1].toFixed(3)); // Negative to invert
        }

        text(`Position:  ${lastPosition[0].toFixed(2) + ", " + lastPosition[2].toFixed(2) + ", " + lastPosition[1].toFixed(2)}`, 360, 40);
        noFill()
        square(370, 60, 300);
        fill(0)
        circle(lastPosition[0] / positionScale + 520, lastPosition[1] / positionScale + 210, 20);
        // If the position is pressed update and send lastPosition
        if (mouseIsPressed && mouseX > 370 && mouseX < 670 && mouseY > 60 && mouseY < 360) {
            lastPosition = [(mouseX - 520) * positionScale, (mouseY - 210) * positionScale, lastPosition[2]];
            // relativePosition = [lastPosition[0] / 150, lastPosition[1] / 150];
            socket.emit('position', -lastPosition[0].toFixed(3), lastPosition[2].toFixed(3), -lastPosition[1].toFixed(3));
        }
        // Position Z Slider (shaped like [] )to the right of the position box
        noFill()
        rect(700, 60, 20, 300);
        fill(0)
        circle(710, -lastPosition[2] / positionScale + 60, 20);
        // If the position is pressed update and send lastPosition
        if (mouseIsPressed && mouseX > 700 && mouseX < 720 && mouseY > 60 && mouseY < 360) {
            lastPosition = [lastPosition[0], lastPosition[1], -(mouseY - 60) * positionScale];
            // relativePosition = [lastPosition[0] / 150, lastPosition[1] / 150];
            socket.emit('position', -lastPosition[0].toFixed(3), lastPosition[2].toFixed(3), -lastPosition[1].toFixed(3));
        }


        // Rotation Visual
        fill(0)
        text(`Rotation:  ${eulerRotation[0].toFixed(2)}, ${eulerRotation[1].toFixed(2)}, ${eulerRotation[2].toFixed(2)}`, 860, 40);
        noFill();
        square(870, 120, 400);
        fill(0)
        stroke(0)
        // Rotation selectors - change each axis individually
        // Y - below rotation box
        fill(255)
        rect(890, 550, 360, 20);
        circle(eulerRotation[1] / rotationScale + 1070, 560, 20);
        if (mouseIsPressed && mouseX > 890 && mouseX < 1250 && mouseY > 550 && mouseY < 570) {
            eulerRotation[1] = (mouseX - 1070) * rotationScale;
            let quArgs = eulerToQuaternion(eulerRotation);
            socket.emit('rotation', quArgs[0].toFixed(3), quArgs[1].toFixed(3), quArgs[2].toFixed(3), quArgs[3].toFixed(3));
        }
        // X - to the left of rotation box
        fill(255)
        rect(820, 140, 20, 360);
        circle(830, eulerRotation[0] / rotationScale + 320, 20);
        if (mouseIsPressed && mouseX > 820 && mouseX < 840 && mouseY > 140 && mouseY < 500) {
            eulerRotation[0] = (mouseY - 320) * rotationScale;
            let quArgs = eulerToQuaternion(eulerRotation);
            socket.emit('rotation', quArgs[0].toFixed(3), quArgs[1].toFixed(3), quArgs[2].toFixed(3), quArgs[3].toFixed(3));
        }
        // Z - to the right of rotation box
        fill(255)
        rect(1290, 140, 20, 360);
        circle(1300, eulerRotation[2] / rotationScale + 320, 20);
        if (mouseIsPressed && mouseX > 1290 && mouseX < 1310 && mouseY > 140 && mouseY < 500) {
            eulerRotation[2] = (mouseY - 320) * rotationScale;
            let quArgs = eulerToQuaternion(eulerRotation);
            socket.emit('rotation', quArgs[0].toFixed(3), quArgs[1].toFixed(3), quArgs[2].toFixed(3), quArgs[3].toFixed(3));
        }


        // Trigger Visual - below position
        fill(0)
        text(`Trigger:  ${trigger[0].toFixed(2)}, ${trigger[1]}`, 400, 400);
        fill(255)
        square(370, 430, 300);
        fill(255, 0, 0)
        // Trigger Visual Line - starts top right and goes bottom right if 0 and top left if 1
        // Calculate the next position of the line (top right of the box is x: 670, y: 430)
        strokeWeight(20);
        line(670, 430, -sin(trigger[0] * 1.57) * 300 + 670, cos(trigger[0] * 1.57) * 300 + 430);
        // If the trigger is pressed update and send trigger
        if (mouseIsPressed && mouseX > 370 && mouseX < 670 && mouseY > 430 && mouseY < 730) {
            overrideTrigger = false;

            trigger[0] = (trigger[0] + 0.01) * 1.57;

            if (trigger[0] > 1) {
                trigger[0] = 1;
            }

            trigger[1] = trigger[0] > 0.9;

            // console.log(trigger[0]);
            // trigger = [1, true];
            // console.log(oldTrigger[0] + " " + trigger[0]);
            if (trigger[0] == oldTrigger[0]) {
                // console.log("Same: " + oldTrigger[0].toFixed(2) + " " + trigger[0].toFixed(2));
            } else {
                socket.emit('trigger', trigger[0].toFixed(3), trigger[1]);
                // console.log("diff " + oldTrigger[0] + " " + trigger[0] + (oldTrigger[0] = parseFloat(trigger[0].toString())));
                oldTrigger[0] = parseFloat(trigger[0].toString())
            }

        } else {
            if (!overrideTrigger) {
                trigger[0] = trigger[0] / 1.5;
            }
            if (trigger[0] < 0.07) {
                trigger[0] = 0;
            }
            if (!overrideTrigger){
                trigger[1] = trigger[0] > 0.9;
            }
            if (trigger[0] == oldTrigger[0]) {
                // console.log("Same: " + oldTrigger[0].toFixed(2) + " " + trigger[0].toFixed(2));
            } else {
                socket.emit('trigger', trigger[0].toFixed(3), trigger[1]);
                // console.log("diff " + oldTrigger[0] + " " + trigger[0] + (oldTrigger[0] = parseFloat(trigger[0].toString())));
                oldTrigger[0] = parseFloat(trigger[0].toString())
            }
            // trigger = [0, false];
            // if (trigger[0] !== oldTrigger[0] || trigger[1] !== oldTrigger[1]) {
            //     socket.emit('trigger', trigger[0].toFixed(3), trigger[0]>0.9);
            //     console.log("emit");
            //     // oldTrigger = trigger;
            // }
        }


        pop();
        translate(-width / 2, -height / 2);
        translate(1020, 350);
        rotateX(eulerRotation[0] / 60);
        rotateY(eulerRotation[1] / 60);
        rotateZ(eulerRotation[2] / 60);
        // Make the 3D shapes white and the lines black
        // fill(255, 0 , 0);
        // ambientLight(255);
        directionalLight(255, 255, 255, 0, 0, -1);
        // noStroke()
        stroke(0)
        shininess(5);
        specularMaterial(5);
        ambientMaterial(255, 0, 255);


        cylinder(33, 225, 24, 16);
        translate(33, -115);
        box(66, 66, 66, 4, 4);

        // sphere(40)
        pop();
    }

    function eulerToQuaternion(eulerAngles) {
        let qua = new CANNON.Quaternion(0, 0, 0, 0);
        qua.setFromEuler(eulerAngles[0] / 180, eulerAngles[1] / 180, eulerAngles[2] / 180);
        return [qua.w, qua.x, qua.y, qua.z];
    }
</script>
</html>