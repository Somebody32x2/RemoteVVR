<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
          name="viewport">
    <meta content="ie=edge" http-equiv="X-UA-Compatible">
    <title>Virtual Controller</title>
    <script crossorigin="anonymous"
            integrity="sha512-3WFaXQUsbGieECwv3t3DvyAkZ7pp+/rIKOQnx7NKhfwIF0u2l+DYsE2eF635ewJVj3YTU4/Ug6UqEkSTZCiSew=="
            referrerpolicy="no-referrer" src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.4.1/socket.io.min.js"></script>

    <link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css"
          integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" rel="stylesheet">
    <script crossorigin="anonymous"
            integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
            src="https://code.jquery.com/jquery-3.2.1.slim.min.js"></script>
    <script crossorigin="anonymous"
            integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"
            src="https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js"></script>
    <script crossorigin="anonymous"
            integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
            src="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js"></script>

    <script crossorigin="anonymous"
            integrity="sha512-keI4Ym3b3tf6N3hp1a1Z8OwXaiZwIu+aNYbU1Rx3QnDAeu8sLGT8ZcBJy5yVbPp9GXyMtr2RGBftngo3K5b4aw=="
            referrerpolicy="no-referrer"
            src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.0/cannon.js"></script>


    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">

</head>
<body oncontextmenu="return false"> <!-- disable right click -->
<div id="buttons">
    <!--    ABXY Buttons-->
    <div class="" id="Y">
        <input autocomplete="off" class="btn-check" id="Y-btn" type="checkbox">
        <label class="btn btn-outline-primary" for="Y-btn"
               oncontextmenu="setButton('Y', document.getElementById('Y-btn').checked)"
               onclick="setButton('Y', document.getElementById('Y-btn').checked)">Y</label>

    </div>
    <div class="" id="X">
        <input autocomplete="off" class="btn-check" id="X-btn" type="checkbox">
        <label class="btn btn-outline-primary" for="X-btn"
               oncontextmenu="setButton('X', document.getElementById('X-btn').checked)"
               onclick="setButton('X', document.getElementById('X-btn').checked)">X</label>

    </div>
    <div class="" id="B">
        <input autocomplete="off" class="btn-check" id="B-btn" type="checkbox">
        <label class="btn btn-outline-primary" for="B-btn"
               oncontextmenu="setButton('B', document.getElementById('B-btn').checked)"
               onclick="setButton('B', document.getElementById('B-btn').checked)">B</label>

    </div>
    <div class="" id="A">
        <input autocomplete="off" class="btn-check" id="A-btn" type="checkbox">
        <label class="btn btn-outline-primary" for="A-btn"
               oncontextmenu="setButton('A', document.getElementById('A-btn').checked)"
               onclick="setButton('A', document.getElementById('A-btn').checked)">A</label>

    </div>
    <div class="" id="SYS">
        <input autocomplete="off" class="btn-check" id="SYS-btn" type="checkbox">
        <label class="btn btn-outline-primary" for="SYS-btn"
               oncontextmenu="setButton('system', document.getElementById('SYS-btn').checked)"
               onclick="setButton('system', document.getElementById('SYS-btn').checked)">SYS</label>

    </div>

    <!--    <input autocomplete="off" class="btn-check" id="shuffle-btn" type="checkbox">-->
    <!--    <label class="btn btn-outline-success" for="shuffle-btn">Shuffle</label>-->
</div>
<div id="settings">
    <label for="posScaleInput">Position Scale:</label><input id="posScaleInput"
                                                             onchange="positionScale = this.value * -0.005"
                                                             type="number"
                                                             value="1">
    <label for="rotScaleInput">Rotation Scale:</label><input id="rotScaleInput" onchange="rotationScale = this.value"
                                                             type="number"
                                                             value="1">
    <label for="setWhat">Set </label>
    <select id="setWhich">
        <option value="l">Left Hand</option>
        <option value="r">Right Hand</option>
    </select>
    <select id="setWhat" onchange="updateSetWhat(this.value)">
        <option selected value="null"></option>
        <optgroup label="Position">
            <option value="positionX">Position X</option>
            <option value="positionY">Position Y</option>
            <option value="positionZ">Position Z</option>
        </optgroup>
        <optgroup label="Rotation">
            <option value="rotationX">Rotation X</option>
            <option value="rotationY">Rotation Y</option>
            <option value="rotationZ">Rotation Z</option>
        </optgroup>
        <optgroup label="Joystick">
            <option value="joystickX">Joystick X</option>
            <option value="joystickY">Joystick Y</option>
        </optgroup>
        <optgroup label="Trackpad">
            <option value="trackpadX">Trackpad X</option>
            <option value="trackpadY">Trackpad Y</option>
        </optgroup>
        <optgroup label="Trigger">
            <option value="triggerV">Trigger Value</option>
            <option value="triggerC">Trigger Pressed</option>
        </optgroup>
    </select>
    <label for="setTo">To </label><input data-set-variable="" id="setTo" onchange="
        if (this.getAttribute('data-set-variable') !== 'trigger[1]') eval('controllerData['+document.getElementById('setWhich')+'].'+this.getAttribute('data-set-variable') +'='+this.value)
        else {eval(this.getAttribute('data-set-variable') +'='+this.checked); overrideTrigger = true}
" type="number">
</div>
</body>
<style>
    body {
        margin: 0;
        height: 100vh;
    }

    #defaultCanvas0 {
        /*Backgroud Canvas Css*/
        width: 100%;
        height: 99.9%;
        position: fixed;
        top: 0;
        left: 0;
        z-index: -1;

    }

    #buttons {
        position: absolute;
        width: 15%;
        height: 15%;
        /*    Right Center Align*/
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        display: grid;
        gap: 4px;
        /*    Place the objects like this:
              y  b
            x     a*/

        grid-template-areas:
        ". a ."
        "b s c"
        ". d .";
    }

    #buttons > div > label {
        width: 100%;
        height: 100%;
        font-size: 1.3rem;
    }

    #Y {
        grid-area: a;
    }

    #X {
        grid-area: b;
    }

    #B {
        grid-area: c;
    }

    #A {
        grid-area: d;
    }

    #SYS {
        grid-area: s;
    }

    #settings {
        /*    Move to bottom Right*/
        position: absolute;
        bottom: 10px;
        right: 10px;
        display: grid;
        gap: 4px;
        grid-template-columns: 1fr 1fr;
    }
</style>
<script>
    let socket = io.connect('http://localhost:3000');
    // let socket = io.connect('https://samuelshuster.com/webcontroller');
    socket.on('connect', function () {
        console.log('Connected');
    });
    socket.on('disconnect', function () {
        console.log('Disconnected');
    });
    socket.on('message', function (data) {
        console.log(data);
    });

    // // Emit all initial values
    // socket.emit('button', leftRight( ,"A", false);
    // socket.emit('button', leftRight( ,"B", false);
    // socket.emit('button', leftRight( ,"X", false);
    // socket.emit('button', leftRight( ,"Y", false);
    // socket.emit('button', leftRight( ,"system", false);
    // socket.emit('joystick', leftRight( ,0, 0);
    // socket.emit('touchpad', leftRight( ,0, 0);
    // socket.emit('trigger', leftRight( ,0, false);
    // socket.emit('position', leftRight( ,0, 0, 0);
    // socket.emit('rotation', leftRight( ,0, 0, 0, 1);


    function setButton(button, state) {
        // Handle rightclicks by manually changing the element state and then calling the function again and also
        // when the button is right pressed (left controller) make the button redder and if both are pressed make it purple but blue if only left is pressed or neither


        // NVM, just send the buttons to the right controller lol
        let lr = "r";
        switch (button) {
            case "X":
                lr = "l";
                button = "A";
                break;
            case "Y":
                lr = "l";
                button = "B";
                break;
        }
        socket.emit('button', lr, button.toLowerCase(), !state);
    }

    function setup() {
        createCanvas(windowWidth, windowHeight, WEBGL);
        background(255);
        // textFont(loadFont('https://fonts.cdnfonts.com/s/29856/MajorMonoDisplay-Regular.woff'));
        textFont(loadFont('https://fonts.cdnfonts.com/s/15669/OverpassMono-Regular.woff'));
        // debugMode();
    }


    // let lastTouchpad = [0, 0];
    // let lastJoystick = [0, 0]
    // let lastPosition = [0, 0, 0];
    let positionScale = -0.005; // Negative to invert - See settings input to change base/initial value
    let rotationScale = 1;
    // let trigger = [0, false]
    // let oldTrigger = [0, false]
    // let lastTrig = 0;
    // let eulerRotation = [0, 0, 0];
    // let overrideTrigger = false;
    let changingHMD = false;
    let lastChangedHMD = 0;

    let HMDZOffset = 560;

    let HMDData = {"position": [0, 0, 0], "eulerRotation": [0, 0, HMDZOffset]}
    let controllerData = {
        r: {
            joystick: [0, 0, false],
            touchpad: [0, 0, false],
            trigger: [0, false],
            lastTrig: 0,
            overrideTrigger: false,
            buttons: {"a": false, "b": false, "x": false, "y": false, "system": false},
            position: [0, 0, 0],
            eulerRotation: [0, 0, 0],
            grip: [0, 0]
        },
        l: {
            joystick: [0, 0, false],
            touchpad: [0, 0, false],
            trigger: [0, false],
            lastTrig: 0,
            overrideTrigger: false,
            buttons: {"a": false, "b": false, "x": false, "y": false, "system": false},
            position: [0, 0, 0],
            eulerRotation: [0, 0, 0],
            grip: [0, 0]
        }
    }

    // Send all the current values to the server
    // function sendAll() {
        for (let i in controllerData) {
            for (let j in controllerData[i].buttons) {
                socket.emit('button', i, j, controllerData[i].buttons[j]);
            }
            socket.emit('joystick', i, controllerData[i].joystick[0], controllerData[i].joystick[1], controllerData[i].joystick[2]);
            socket.emit('touchpad', i, controllerData[i].touchpad[0], controllerData[i].touchpad[1], controllerData[i].touchpad[2]);
            socket.emit('trigger', i, controllerData[i].trigger[0], controllerData[i].trigger[1]);
            socket.emit('position', i, controllerData[i].position[0], controllerData[i].position[1], controllerData[i].position[2]);
            socket.emit('rotation', i, controllerData[i].eulerRotation[0], controllerData[i].eulerRotation[1], controllerData[i].eulerRotation[2], controllerData[i].eulerRotation[3]);
            socket.emit('grip', i, controllerData[i].grip[0], controllerData[i].grip[1]);
        }
    // }
    // sendAll();


    function updateSetWhat(what) {
        let lr = document.getElementById('setWhich').value;
        switch (what) {
            case "positionX":
                document.getElementById("setTo").setAttribute("type", "number");
                document.getElementById("setTo").value = controllerData[lr].position[0];
                document.getElementById("setTo").setAttribute("data-set-variable", "position[0]");
                break;
            case "positionY":
                document.getElementById("setTo").setAttribute("type", "number");
                document.getElementById("setTo").value = controllerData[lr].position[1];
                document.getElementById("setTo").setAttribute("data-set-variable", "position[1]");
                break;
            case "positionZ":
                document.getElementById("setTo").setAttribute("type", "number");
                document.getElementById("setTo").value = controllerData[lr].position[2];
                document.getElementById("setTo").setAttribute("data-set-variable", "position[2]");
                break;
            case "rotationX":
                document.getElementById("setTo").setAttribute("type", "number");
                document.getElementById("setTo").value = controllerData[lr].eulerRotation[0];
                document.getElementById("setTo").setAttribute("data-set-variable", "eulerRotation[0]");
                break;
            case "rotationY":
                document.getElementById("setTo").setAttribute("type", "number");
                document.getElementById("setTo").value = controllerData[lr].eulerRotation[1];
                document.getElementById("setTo").setAttribute("data-set-variable", "eulerRotation[1]");
                break;
            case "rotationZ":
                document.getElementById("setTo").setAttribute("type", "number");
                document.getElementById("setTo").value = controllerData[lr].eulerRotation[2];
                document.getElementById("setTo").setAttribute("data-set-variable", "eulerRotation[2]");
                break;
            case "joystickX":
                document.getElementById("setTo").setAttribute("type", "number");
                document.getElementById("setTo").value = controllerData[lr].joystick[0];
                document.getElementById("setTo").setAttribute("data-set-variable", "joystick[0]");
                break;
            case "joystickY":
                document.getElementById("setTo").setAttribute("type", "number");
                document.getElementById("setTo").value = controllerData[lr].joystick[1];
                document.getElementById("setTo").setAttribute("data-set-variable", "joystick[1]");
                break;
            case "trackpadX":
                document.getElementById("setTo").setAttribute("type", "number");
                document.getElementById("setTo").value = controllerData[lr].touchpad[0];
                document.getElementById("setTo").setAttribute("data-set-variable", "touchpad[0]");
                break;
            case "trackpadY":
                document.getElementById("setTo").setAttribute("type", "number");
                document.getElementById("setTo").value = controllerData[lr].touchpad[1];
                document.getElementById("setTo").setAttribute("data-set-variable", "touchpad[1]");
                break;
            case "triggerV":
                document.getElementById("setTo").value = controllerData[lr].trigger[0];
                document.getElementById("setTo").setAttribute("type", "number");
                document.getElementById("setTo").setAttribute("data-set-variable", "trigger[0]");
                controllerData[lr].overrideTrigger = true;
                break;
            case "triggerC":
                document.getElementById("setTo").setAttribute("data-set-variable", "trigger[1]");
                document.getElementById("setTo").setAttribute("type", "checkbox");
                document.getElementById("setTo").checked = controllerData[lr].trigger[1];
                controllerData[lr].overrideTrigger = true;
                break;


        }
    }
    let lastTClick = 0;
    let lastJClick = 0;
    function draw() {
        // orbitControl();
        push();
        push();
        translate(-width / 2, -height / 2, 0);
        background(255);

        textSize(20);

        // region Touchpad
        fill(0);
        text('Touchpad', 40, 40);

        noFill()
        square(10, 60, 300);
        circle(160, 210, 300);

        fill(0)
        circle(controllerData["r"].touchpad[0] + 160, controllerData["r"].touchpad[1] + 210, 20);
        fill(255, 0, 0)
        circle(controllerData["l"].touchpad[0] + 160, controllerData["l"].touchpad[1] + 210, 20);
        fill(0)
        // If the touchpad is pressed update and send lastTouchpad
        if (mouseIsPressed && mouseX > 10 && mouseX < 310 && mouseY > 60 && mouseY < 360) {
            controllerData[leftRight()].touchpad = [mouseX - 160, mouseY - 210];
            socket.emit('touchpad', leftRight(), (controllerData[leftRight()].touchpad[0] / 150).toFixed(3), -(controllerData[leftRight()].touchpad[1] / 150).toFixed(3), controllerData[leftRight()].touchpad[3]);
        }

        // Touchpad Click Box (Next to text)
        fill(255);
        square(240, 5, 50);
        fill(255);
        text('Click', 350, 110);
        if (controllerData["r"].touchpad[3]) {
            fill(0, 0, 0, 100);
            square(240, 5, 50);
        }
        if (controllerData["l"].touchpad[3]) {
            fill(255, 0, 0, 100);
            square(240, 5, 50);
        }
        if (mouseIsPressed && mouseX > 240 && mouseX < 290 && mouseY > 5 && mouseY < 55 && millis() - lastTClick > 200) {
            lastTClick = millis();
            controllerData[leftRight()].touchpad[3] = !controllerData[leftRight()].touchpad[3];
            socket.emit('touchpad', leftRight(), (controllerData[leftRight()].touchpad[0] / 150).toFixed(3), -(controllerData[leftRight()].touchpad[1] / 150).toFixed(3), controllerData[leftRight()].touchpad[3]);
        }



        // endregion

        // region Joystick
        fill(0);
        text('Joystick', 40, 400);
        noFill()
        square(10, 430, 300);
        circle(160, 580, 300);
        fill(0)
        circle(controllerData["r"].joystick[0] + 160, controllerData["r"].joystick[1] + 580, 20);
        fill(255, 0, 0)
        circle(controllerData["l"].joystick[0] + 160, controllerData["l"].joystick[1] + 580, 20);
        fill(0)
        // If the joystick is pressed update and send lastJoystick
        if (mouseIsPressed && mouseX > 10 && mouseX < 310 && mouseY > 430 && mouseY < 730) {
            controllerData[leftRight()].joystick = [mouseX - 160, mouseY - 580];
            socket.emit('joystick', leftRight(), (controllerData[leftRight()].joystick[0] / 150).toFixed(3), -(controllerData[leftRight()].joystick[1] / 150).toFixed(3));
        }

        // Joystick Click Box (Next to text)
        fill(255);
        square(240, 365, 50);
        fill(255);
        text('Click', 350, 470);
        if (controllerData["r"].joystick[2]) {
            fill(0, 0, 0, 100);
            square(240, 365, 50);
        }
        if (controllerData["l"].joystick[2]) {
            fill(255, 0, 0, 100);
            square(240, 365, 50);
        }
        if (mouseIsPressed && mouseX > 240 && mouseX < 290 && mouseY > 365 && mouseY < 415 && millis() - lastJClick > 200) {
            lastJClick = millis();
            controllerData[leftRight()].joystick[2] = !controllerData[leftRight()].joystick[2];
            socket.emit('joystick', leftRight(), (controllerData[leftRight()].joystick[0] / 150).toFixed(3), -(controllerData[leftRight()].joystick[1] / 150).toFixed(3), controllerData[leftRight()].joystick[2]);
        }
        // endregion

        // region Position
        fill(0);
        text(`Position:  ${controllerData[leftRight()].position[0].toFixed(2) + ", " + controllerData[leftRight()].position[2].toFixed(2) + ", " + controllerData[leftRight()].position[1].toFixed(2)}`, 360, 40);
        noFill()
        square(370, 60, 300);
        fill(0)
        circle(controllerData["r"].position[0] / positionScale + 520, controllerData["r"].position[1] / positionScale + 210, 20);
        fill(255, 0, 0)
        circle(controllerData["l"].position[0] / positionScale + 520, controllerData["l"].position[1] / positionScale + 210, 20);
        fill(0, 255, 0, 100)
        circle(HMDData.position[0] / positionScale + 520, HMDData.position[1] / positionScale + 210, 20);
        fill(0)
        // If the position is pressed update and send lastPosition
        if (mouseIsPressed && mouseX > 370 && mouseX < 670 && mouseY > 60 && mouseY < 360) {
            if (!changingHMD) {
                controllerData[leftRight()].position = [(mouseX - 520) * positionScale, (mouseY - 210) * positionScale, controllerData[leftRight()].position[2]];
                socket.emit('position', leftRight(), -controllerData[leftRight()].position[0].toFixed(3), controllerData[leftRight()].position[2].toFixed(3), -controllerData[leftRight()].position[1].toFixed(3));
            } else {
                HMDData.position = [(mouseX - 520) * positionScale, (mouseY - 210) * positionScale, HMDData.position[2]];
                socket.emit('position', "h", -HMDData.position[0].toFixed(3), HMDData.position[2].toFixed(3), -HMDData.position[1].toFixed(3));
            }
        }

        // Position Z Slider (shaped like [] )to the right of the position box
        noFill()
        rect(700, 60, 20, 300);
        fill(0)
        circle(710, -controllerData["r"].position[2] / positionScale + 60, 20);
        fill(255, 0, 0)
        circle(710, -controllerData["l"].position[2] / positionScale + 60, 20);
        fill(0, 255, 0, 100)
        circle(710, -HMDData.position[2] / positionScale + 60, 20);
        fill(0)
        // If the position is pressed update and send lastPosition
        if (mouseIsPressed && mouseX > 700 && mouseX < 720 && mouseY > 60 && mouseY < 360) {
            if (!changingHMD) {
                controllerData[leftRight()].position = [controllerData[leftRight()].position[0], controllerData[leftRight()].position[1], -(mouseY - 60) * positionScale];
                socket.emit('position', leftRight(), -controllerData[leftRight()].position[0].toFixed(3), controllerData[leftRight()].position[2].toFixed(3), -controllerData[leftRight()].position[1].toFixed(3));
            } else {
                HMDData.position[2] = -(mouseY - 60) * positionScale
                socket.emit('position', "h", -HMDData.position[0].toFixed(3), HMDData.position[2].toFixed(3), -HMDData.position[1].toFixed(3));
            }
        }
        // endregion

        // region Changing HMD Toggle Button
        if (changingHMD) fill(0, 255, 0);
        else fill(255, 255, 255);
        rect(750, 70, 100, 50);

        fill(0);
        text('HMD', 760, 100);

        if (mouseIsPressed && mouseX > 750 && mouseX < 850 && mouseY > 70 && mouseY < 130 && lastChangedHMD + 100 < millis()) {
            changingHMD = !changingHMD;
            lastChangedHMD = millis();
        }
        // endregion


        // region Rotation Visual
        fill(0)
        text(`Rotation:  ${controllerData[leftRight()].eulerRotation[0].toFixed(2)}, ${controllerData[leftRight()].eulerRotation[1].toFixed(2)}, ${controllerData[leftRight()].eulerRotation[2].toFixed(2)}`, 860, 40);
        noFill();
        square(870, 120, 400);
        fill(0)
        stroke(0)
        // Rotation selectors - change each axis individually
        // Y - below rotation box
        fill(255)
        rect(890, 550, 360, 20);
        circle(-controllerData["r"].eulerRotation[1] / rotationScale + 1070, 560, 20);
        fill(255, 0, 0)
        circle(-controllerData["l"].eulerRotation[1] / rotationScale + 1070, 560, 20);
        fill(0, 255, 0, 100)
        circle(-HMDData.eulerRotation[1] / rotationScale + 1070, 560, 20);
        fill(0)
        if (mouseIsPressed && mouseX > 890 && mouseX < 1250 && mouseY > 550 && mouseY < 570) {
            if (!changingHMD) {
                controllerData[leftRight()].eulerRotation[1] = -(mouseX - 1070) * rotationScale;
                let quArgs = eulerToQuaternion(controllerData[leftRight()].eulerRotation);
                socket.emit('rotation', leftRight(), quArgs[0].toFixed(3), quArgs[1].toFixed(3), quArgs[2].toFixed(3), quArgs[3].toFixed(3));
            } else {
                HMDData.eulerRotation[1] = -(mouseX - 1070) * rotationScale;
                let quArgs = eulerToQuaternion(HMDData.eulerRotation);
                socket.emit('rotation', "h", quArgs[0].toFixed(3), quArgs[1].toFixed(3), quArgs[2].toFixed(3), quArgs[3].toFixed(3));
            }
        }
        // X - to the left of rotation box
        let thisRotIndex = 0;
        fill(255)
        rect(820, 140, 20, 360);
        circle(830, controllerData["r"].eulerRotation[thisRotIndex] / rotationScale + 320, 20);
        fill(255, 0, 0)
        circle(830, controllerData["l"].eulerRotation[thisRotIndex] / rotationScale + 320, 20);
        fill(0, 255, 0, 100)
        circle(830, HMDData.eulerRotation[thisRotIndex] / rotationScale + 320, 20);
        fill(0)
        if (mouseIsPressed && mouseX > 820 && mouseX < 840 && mouseY > 140 && mouseY < 500) {
            if (!changingHMD) {
                controllerData[leftRight()].eulerRotation[thisRotIndex] = (mouseY - 320) * rotationScale;
                let quArgs = eulerToQuaternion(controllerData[leftRight()].eulerRotation);
                socket.emit('rotation', leftRight(), quArgs[0].toFixed(3), quArgs[1].toFixed(3), quArgs[2].toFixed(3), quArgs[3].toFixed(3));
            } else {
                HMDData.eulerRotation[thisRotIndex] = (mouseY - 320) * rotationScale;
                let quArgs = eulerToQuaternion(HMDData.eulerRotation);
                socket.emit('rotation', "h", quArgs[0].toFixed(3), quArgs[1].toFixed(3), quArgs[2].toFixed(3), quArgs[3].toFixed(3));
            }
        }
        // Z - to the right of rotation box
        thisRotIndex = 2
        fill(255)
        rect(1290, 140, 20, 360);
        circle(1300, (controllerData["r"].eulerRotation[thisRotIndex] - HMDZOffset) / rotationScale + 320, 20);
        fill(255, 0, 0)
        circle(1300, (controllerData["l"].eulerRotation[thisRotIndex] - HMDZOffset) / rotationScale + 320, 20);
        fill(0, 255, 0, 100)
        circle(1300, (HMDData.eulerRotation[thisRotIndex] - HMDZOffset) / rotationScale + 320, 20);
        fill(0)
        if (mouseIsPressed && mouseX > 1290 && mouseX < 1310 && mouseY > 140 && mouseY < 500) {
            if (!changingHMD) {
                controllerData[leftRight()].eulerRotation[thisRotIndex] = HMDZOffset + ((mouseY - 320) * rotationScale);
                let quArgs = eulerToQuaternion(controllerData[leftRight()].eulerRotation);
                socket.emit('rotation', leftRight(), quArgs[0].toFixed(3), quArgs[1].toFixed(3), quArgs[2].toFixed(3), quArgs[3].toFixed(3));
            } else {
                HMDData.eulerRotation[thisRotIndex] = HMDZOffset + ((mouseY - 320) * rotationScale);
                let quArgs = eulerToQuaternion(HMDData.eulerRotation);
                socket.emit('rotation', "h", quArgs[0].toFixed(3), quArgs[1].toFixed(3), quArgs[2].toFixed(3), quArgs[3].toFixed(3));
            }
        }
        // endregion

        // region Grips
        // Grip Value - below rotation box - only controllers
        text(`Grip:  V: ${controllerData[leftRight()].grip[0].toFixed(2)}   F: ${controllerData[leftRight()].grip[1].toFixed(2)}`, 860, 600);
        fill(255)
        rect(890, 640, 360, 20);
        fill(0, 0, 0, 100)
        rect(890, 640, controllerData["r"].grip[0] * 360, 20);
        fill(255, 0, 0, 100)
        rect(890, 640, controllerData["l"].grip[0] * 360, 20);

        if (mouseIsPressed && mouseX > 890 && mouseX < 1250 && mouseY > 640 && mouseY < 660) {
            controllerData[leftRight()].grip[0] = (mouseX - 890) / 360;
            socket.emit("grip", leftRight(), controllerData[leftRight()].grip[0].toFixed(3), controllerData[leftRight()].grip[1].toFixed(3));
        }

        // Grip Force
        fill(255)
        rect(890, 680, 360, 20);
        fill(0, 0, 0, 100)
        rect(890, 680, controllerData["r"].grip[1] * 360, 20);
        fill(255, 0, 0, 100)
        rect(890, 680, controllerData["l"].grip[1] * 360, 20);

        if (mouseIsPressed && mouseX > 890 && mouseX < 1250 && mouseY > 680 && mouseY < 700) {
            controllerData[leftRight()].grip[1] = (mouseX - 890) / 360;
            socket.emit("grip", leftRight(), controllerData[leftRight()].grip[0].toFixed(3), controllerData[leftRight()].grip[1].toFixed(3));
        }
        // endregion

        // region Triggers
        // Trigger Visual - below position
        fill(0)
        text(`Trigger:  ${controllerData[leftRight()].trigger[0].toFixed(2)}, ${controllerData[leftRight()].trigger[1]}`, 400, 400);
        fill(255)
        square(370, 430, 300);
        fill(255, 0, 0)
        // Trigger Visual Line - starts top right and goes bottom right if 0 and top left if 1
        // Calculate the next position of the line (top right of the box is x: 670, y: 430)
        strokeWeight(20);
        line(670, 430, -sin(controllerData["r"].trigger[0] * 1.57) * 300 + 670, cos(controllerData["r"].trigger[0] * 1.57) * 300 + 430);
        stroke(255, 0, 0)
        line(670, 430, -sin(controllerData["l"].trigger[0] * 1.57) * 300 + 670, cos(controllerData["l"].trigger[0] * 1.57) * 300 + 430);
        stroke(0)
        // If the trigger is pressed update and send trigger
        if (mouseIsPressed && mouseX > 370 && mouseX < 670 && mouseY > 430 && mouseY < 730) {
            overrideTrigger = false;

            controllerData[leftRight()].trigger[0] = (controllerData[leftRight()].trigger[0] + 0.01) * 1.57;

            if (controllerData[leftRight()].trigger[0] > 1) {
                controllerData[leftRight()].trigger[0] = 1;
            }

            controllerData[leftRight()].trigger[1] = controllerData[leftRight()].trigger[0] > 0.9;

            // console.log(trigger[0]);
            // trigger = [1, true];
            // console.log(oldTrigger[0] + " " + trigger[0]);
            if (controllerData[leftRight()].trigger[0] === controllerData[leftRight()].lastTrigger) {
                // console.log("Same: " + oldTrigger[0].toFixed(2) + " " + trigger[0].toFixed(2));
            } else {
                socket.emit('trigger', leftRight(), controllerData[leftRight()].trigger[0].toFixed(3), controllerData[leftRight()].trigger[1]);
                // console.log("diff " + oldTrigger[0] + " " + trigger[0] + (oldTrigger[0] = parseFloat(trigger[0].toString())));
                controllerData[leftRight()].lastTrig = parseFloat(controllerData[leftRight()].trigger[0].toString())
            }

        } else {
            for (let lr = "l"; lr !== "d"; lr === "l" ? lr = "r" : lr = "d") {
                if (!controllerData[lr].overrideTrigger) {
                    controllerData[lr].trigger[0] = controllerData[lr].trigger[0] / 1.5;
                }
                if (controllerData[lr].trigger[0] < 0.07) {
                    controllerData[lr].trigger[0] = 0;
                }
                if (!controllerData[lr].overrideTrigger) {
                    controllerData[lr].trigger[1] = controllerData[lr].trigger[0] > 0.9;
                }
                if (controllerData[lr].trigger[0] === controllerData[lr].lastTrig) {
                    // console.log("same " + lr)
                } else {
                    socket.emit('trigger', lr, controllerData[lr].trigger[0].toFixed(3), controllerData[lr].trigger[1]);
                    // console.log("diff " + lr + " " + controllerData[lr].trigger[0] + " " + controllerData[lr].lastTrig)
                    controllerData[lr].lastTrig = parseFloat(controllerData[lr].trigger[0].toString())
                }
            }
            // trigger = [0, false];
            // if (trigger[0] !== oldTrigger[0] || trigger[1] !== oldTrigger[1]) {
            //     socket.emit('trigger', leftRight( ,trigger[0].toFixed(3), trigger[0]>0.9);
            //     console.log("emit");
            //     // oldTrigger = trigger;
            // }
        }
        // endregion

        // region Rotation Rendering
        pop();
        translate(-width / 2, -height / 2);
        translate(1020, 350);

        shininess(5);
        specularMaterial(5);
        push()
        directionalLight(100, 100, 100, 0, 0, -1);

        rotateX(-(controllerData["r"].eulerRotation[2] - HMDZOffset) / 180);
        rotateY(-(controllerData["r"].eulerRotation[1]) / 180);
        rotateZ(-(controllerData["r"].eulerRotation[0]) / 180);

        ambientMaterial(255, 0, 255);

        fill(255, 255, 255, 100);
        stroke(100, 100, 100, 100);

        cylinder(33, 225, 24, 16);
        translate(33, -115);
        box(66, 66, 66, 4, 4);

        pop()
        push()

        directionalLight(255, 0, 0, 0, 0, -1);

        rotateX(-(controllerData["l"].eulerRotation[2] - HMDZOffset) / -180);
        rotateY(-(controllerData["l"].eulerRotation[1]) / -180);
        rotateZ(-(controllerData["l"].eulerRotation[0]) / -180);

        ambientMaterial(255, 0, 0);

        fill(255, 0, 0, 100);
        stroke(100, 0, 0, 100);

        cylinder(33, 225, 24, 16);
        translate(33, -115);
        box(66, 66, 66, 4, 4);

        pop()
        push()

        // HMD Repersentation
        translate(50, 0, 0)
        directionalLight(0, 255, 0, 0, 0, -1);

        rotateX(-(HMDData.eulerRotation[2] - HMDZOffset) / 180);
        rotateY(-HMDData.eulerRotation[1] / 180);
        rotateZ(-HMDData.eulerRotation[0] / 180);

        ambientMaterial(0, 255, 0);

        fill(0, 255, 0, 50);
        stroke(0, 255, 0, 50);

        box(200, 100, 100, 4, 4);
        translate(0, 0, 10)
        box(175, 75, 100, 4, 4);


        // Make the 3D shapes white and the lines black
        // fill(255, 0 , 0);
        // ambientLight(255);
        // noStroke()


        // sphere(40)
        // endregion
        pop();
    }

    function leftRight() {
        return mouseButton === RIGHT ? "l" : "r";
    }

    function eulerToQuaternion(eulerAngles) {
        let qua = new CANNON.Quaternion(0, 0, 0, 0);
        qua.setFromEuler(eulerAngles[0] / 180, eulerAngles[1] / 180, eulerAngles[2] / 180);
        return [qua.w, qua.x, qua.y, qua.z];
    }
</script>
</html>